setwd("/Users/Amanda/Dropbox/Thesis/Paper6-rPackage/inarbp")
source("inarbp.R")  # includes the function that links R to C
# Validating functions and studying precision #
# n: size of series
# p: 2-dimensional parameter vector (alpha, lambda)
inar.sim=function(n,p,...)
{
x=NULL
x[1]=rpois(1,p[2]/(1-p[1]))
for(j in 2:n) x[j]=rbinom(1,x[j-1],p[1])+rpois(1,p[2])
return(x)
}
x.sim=inar.sim(n=1000,p=c(0.7,8))
p.ini=c(0.5,5)
inarbp.mle=function(xdata,param,iprint=1,...)
return(nlm(inarbp.nllk,p=param,xdata=xdata,iprint=0))
cat(param,"\n")
nllk=inarbp.nllk(param=p.ini,xdata=x.sim,iprint=1)
print(nllk)
inarbp.mle(xdata=x.sim,param=p.ini,iprin=1)
system.time(inarbp.mle(xdata=x.sim,param=p.ini,iprint=1))
nllk=inarbp.nllk(param=p.ini,xdata=x.sim,iprint=2)
nllk=inarbp.nllk(param=p.ini,xdata=x.sim,iprint=0)
print(nllk)
inarbp.mle(xdata=x.sim,param=p.ini,iprin=1)
system.time(inarbp.mle(xdata=x.sim,param=p.ini,iprint=1))
invchf<-function(x,fn,param=0,iprint=F)
{ x1=x+1
tem1<-integrate(fn,-pi,0,xx=x1,param=param)
tem2<-integrate(fn,0,pi,xx=x1,param=param)
tem<-(tem1$v+tem2$v)/(2*pi)
if(iprint) cat("integrals + cdf:",tem1$v,tem2$v,.5-tem,"\n")
.5-tem
}
getcdfpmf=function(xmx, fnchf, param, iprint=F)
{ # cdf
cdfvec=rep(0,xmx+1)
for(x in 0:xmx)
{ cdfvec[x+1]=invchf(x, fn=fnchf, param=param)
if(iprint) cat("x=",x, "cdf=", cdfvec[x+1],"\n")
}
# pmf
pmfvec=diff(c(0,cdfvec))
#  print(pmfvec)
cbind(0:xmx,pmfvec,cdfvec)
}
# output: integrand (for use in integration)
I2gkxchf=function(u,xx,param)
{ alp=param[1]; gam=param[2]; xprev=param[3]
a1=1-alp
# check if code works for xprev=0
z=exp(u*1i)
gk=(a1+(alp-gam)*z)/(1-alp*gam-a1*gam*z) # chf of I2 operator
ph=gk^xprev  # xprev-fold convolution
tem=ph*exp(-u*xx*1i)/(1-exp(-u*1i))
#print(cbind(u,z,ph,tem))
Re(tem)
}
# extended binomial distribution for the I2 operator
# Xnew = sum_{i=1}^x K_i(alp,gam) I2\n")
# xmx = upper bound for cdf and pmf of  Xnew random variable
# param = parameter vector for chf (characteristic function)
#        (alp, gam, xprev)  : xprev is non-negative integer
# output pmf of rv Xnew from 0,...,xmx
ebinomI2=function(xmx,param)
{ if(param[3]==0) return(c(1,rep(0,xmx)))
tem=getcdfpmf(xmx, fnchf=I2gkxchf, param)
tem[,2]
}
cat("\nchecking getcdfpmf for sum_{i=1}^xprev K_i(alp,gam) I2\n")
ub=4
gam=.1
#gam=.01
#gam=.001
xprev=4
#xprev=0 # works properly in this case
tem=getcdfpmf(ub, fnchf=I2gkxchf, param=c(.5,gam=.1,xprev))
cat("alp=0.5, gam=.1, xprev=4\n")
print(tem)
a.aux=c(I2.NB.pmf(x=4,y=0,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=1,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=2,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=3,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=4,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=5,p=c(0.5,0.10,2.6)))
I2.NB.pmf=function(x,y,p)
{
x=x; y=y; p=p
I2.NB.chf=function(u)
{
zz=exp(u*1i)
MK=(((1-p[1])+(p[1]-p[2])*zz)/((1-p[1]*p[2])-(1-p[1])*p[2]*zz))
Mt=(MK^x)
return(Re(Mt*exp(-1i*u*y)/(1-exp(-1i*u))))
}
temp.l=integrate(I2.NB.chf,-pi,0)
temp.u=integrate(I2.NB.chf,0,pi)
return(.5-(1/(2*pi))*(temp.l$value+temp.u$value))
}
a.aux=c(I2.NB.pmf(x=4,y=0,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=1,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=2,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=3,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=4,p=c(0.5,0.10,2.6)),
I2.NB.pmf(x=4,y=5,p=c(0.5,0.10,2.6)))
a.aux
tem
